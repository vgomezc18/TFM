---
title: "Contraste de métodos de imputación estadística en la documentación de víctimas del
conflicto armado colombiano"
author: "Valentina Gómez^[[valegome@ucm.es](valegome@ucm.es)]"
date: '`r format(Sys.time(), "%d %B %Y")`'
output: pdf_document
site: "bookdown::bookdown_site"
lang: es-CO
fig_width: 4
fig_height: 2.5
fontsize: 12pt
urlcolor: blue
editor_options: 
  markdown: 
    wrap: sentence
---
# Imputación por Machine Learning - Sexo - RF

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

require(pacman)
p_load(here, tidyverse, dplyr, data.table, ranger, caret, ggplot2, pROC, rpart)

```

Importación de datos:

```{r}
input_dir <- here::here("06.union/output")
output_dir <- here::here("08.modelos_imputacion/output")

data.dt <- readRDS(paste0(input_dir,"/violencias_unidas_aux.rds")) %>%
	as.data.table()
```

Imputación de la variable sexo usando un modelo de random forest y paquete ranger:

Se utilizan los valores NA como otra categoria, llamada * para imputar el sexo y se convierte en factor la variable sexo.

```{r}
data.dt[
  , sexo := factor(sexo)][  
  is.na(etnia), etnia := '*'][
  is.na(edad_categoria), edad_categoria := '*'][
  is.na(edad_jep), edad_jep := '*'][
  is.na(p_str), p_str := '*']

table(data.dt$etnia, useNA = "a")
table(data.dt$edad_categoria, useNA = "a")
table(data.dt$edad_jep, useNA = "a")
table(data.dt$p_str, useNA = "a")
          
```
Se establecen los regresores que se utilizaran en el modelo

```{r}
# Prepare data ####
regressors_sexo <- c(
  "macroregion", "dept_code_hecho", "muni_code_hecho", "muni_code_hecho_imp", "areaoficialkm2_mpio", "discapital_mpio", "frontera_mpio",
  "yy_hecho",
  "violencia", 
  "etnia", "p_str", "edad_categoria",
  "pobl_tot_mpio", "indrural_mpio", "predo_rural_mpio",
  "y_transf_depto", "g_func_general_depto",  
  "H_coca_depto",
  "asistesc_depto", "per_alfa_depto", "alumn_total_depto")

```

Se dividen los datos en dos conjuntos, uno donde sexo no es NA y que se usará para entrenar el modelo, y otro en donde el sexo es NA y se utiliza para la imputación.

```{r}
data_sexo.dt <- data.dt[          # datos para contruir el modelo
  !is.na(sexo)][
  , c('sexo', regressors_sexo), with = FALSE]
 
data_sexo_impute.dt <- data.dt[   # datos a imputar
  is.na(sexo)][ # Unidades a imputar 
  , c('sexo', regressors_sexo), with = FALSE] 

```


Se construye el modelo, pero el conjunto de datos esta desbalanceado (hay más hombres que mujeres) entonces se realiza un submuestreo para balancear la cantidad de observaciones de cada sexo.


```{r}
table(data_sexo.dt$sexo, useNA = 'always')
n_mujeres <- data_sexo.dt[sexo == 'MUJER', .N]
n_hombres <- data_sexo.dt[sexo == 'HOMBRE', .N]

set.seed(412)
data_sexo_undersampl.dt <- rbindlist(list(
  data_sexo.dt[sexo == 'HOMBRE'][
    sample(c(TRUE, FALSE), n_hombres, prob = c(n_mujeres / n_hombres, 1 - n_mujeres / n_hombres) , replace = TRUE)],
  data_sexo.dt[sexo == 'MUJER']))
table(data_sexo_undersampl.dt$sexo, useNA = 'always')
```
Ahora se construye un modelo de random forest con los datos submuestreados y se ajustan los hiperparametros.

Entrenamiento y validación del modelo con K-Fold Cross-Validation:

```{r}
## Manual (non-repeated) k-fold cross-validation ####
## Grid search for hyperparameters
grid_hyperp.dt <- as.data.table(expand.grid(
  mtry = c(4, length(regressors_sexo) - 3), #mtry es el número de variables que el modelo considerará al hacer un split en cada nodo de un árbol
  min.node.size = c(50, 500), #min.node.size es el tamaño mínimo que deben tener los nodos terminales de un árbol. Se prueba 50 y 500
  num.trees = c(100, 500))) # num.trees es el número total de árboles en el bosque. Se prueba 100 y 500

#Construimos los 5 folds
n_rf    <- nrow(data_sexo_undersampl.dt)
n_folds <- 5
set.seed(543) # For k-fold reproducibility
data_sexo_undersampl.dt[, fold_idx := sample(1:n_folds, n_rf, replace = TRUE)]

# Train-test para cada fold y cada celda de hiperparametros
roc_sexo_train.lst <- vector(mode = 'list', length = nrow(grid_hyperp.dt))
roc_sexo_test.lst  <- vector(mode = 'list', length = nrow(grid_hyperp.dt))
prob_sexo_test.lst  <- vector(mode = 'list', length = nrow(grid_hyperp.dt))
n_cells <- nrow(grid_hyperp.dt)

for (grid_id in 1:n_cells){
  
  mtry          <- grid_hyperp.dt[grid_id][['mtry']]
  min.node.size <- grid_hyperp.dt[grid_id][['min.node.size']]
  num.trees     <- grid_hyperp.dt[grid_id][['num.trees']]
  
  cat(paste0('mtry= ', mtry, '; min.node.size= ', min.node.size, '; num.trees= ', num.trees, '\n'))
  
  roc_sexo_train.lst[[grid_id]] <- vector('list', n_folds)
  
  for (fold in 1:n_folds){
    
    
    data_train.dt <- data_sexo_undersampl.dt[fold_idx != fold]
    data_test.dt  <- data_sexo_undersampl.dt[fold_idx == fold]
    model_sexo <- ranger(
      sexo ~ ., 
      data = data_train.dt,
      splitrule = "gini",
      mtry = mtry,
      min.node.size = min.node.size,
      num.trees = num.trees,
      probability = TRUE)
    pred_sexo_train  <- predict(model_sexo, data = data_train.dt)
    roc_sexo_train.lst[[grid_id]][[fold]] <- roc(data_train.dt$sexo, pred_sexo_train$predictions[, 'HOMBRE'], levels = c('HOMBRE', 'MUJER'))
    
    pred_sexo_test  <- predict(model_sexo, data = data_test.dt)
    roc_sexo_test.lst[[grid_id]][[fold]] <- roc(data_test.dt$sexo, pred_sexo_test$predictions[, 'HOMBRE'], levels = c('HOMBRE', 'MUJER')) 
    prob_sexo_test.lst[[grid_id]][[fold]] <- pred_sexo_test$predictions
    cat(paste0('   fold= ', fold, '; auc_pred= ', auc(roc_sexo_test.lst[[grid_id]][[fold]]), '\n'))
  }    
  names(roc_sexo_train.lst[[grid_id]]) <- paste0('fold= ', 1:n_folds)
  names(roc_sexo_test.lst[[grid_id]])  <- paste0('fold= ', 1:n_folds)

}
names(roc_sexo_train.lst) <- paste0('hyper_cell= ', 1:n_cells)
names(roc_sexo_test.lst) <- paste0('hyper_cell= ', 1:n_cells)

# saveRDS(roc_sexo_train.lst, (paste0(output_dir,"/roc_sexo_train.lst.rds")))
# saveRDS(roc_sexo_test.lst, (paste0(output_dir,"/roc_sexo_test.lst.rds")))

```

Selección de los mejores hiperparámetros:

```{r}
#Calculamos el AUC en cada fold y cada celda
auc_sexo_train.lst <- lapply(roc_sexo_train.lst, function(lst){sapply(lst, function(roc){auc(roc)})})
auc_sexo_train.lst

auc_sexo_test.lst  <- lapply(roc_sexo_test.lst,  function(lst){sapply(lst, function(roc){auc(roc)})})
auc_sexo_test.lst

# Tomamos la media de las AUC en cada celda
auc_sexo_train_main <- sapply(auc_sexo_train.lst, mean)
auc_sexo_train_main

auc_sexo_test_main <- sapply(auc_sexo_test.lst, mean)
auc_sexo_test_main

auc.dt <- data.table(
  hyper_cell = seq_along(auc_sexo_test_main), 
  train = round(auc_sexo_train_main, 3), 
  test  = round(auc_sexo_test_main, 3))
auc.dt <- auc.dt[
  grid_hyperp.dt[, hyper_cell := 1:.N], on = 'hyper_cell']
auc.dt[which.max(auc.dt$test)] # Selecciono el AUC máximo.
# (el modelo optimo parece darse cuando mtry es bajo, min.node-size es bajo y num.trees es alto)
# (el valor de auc no es muy bueno; quiza haya que probar un boosting)
# (el undersampling no parece mejorar el modelo)
# (la cantidad de overfitting no parece reducirse mucho con el undersampling)

```

Se construye un modelo Random Forest (ranger) con los datos submuestreados. 
Se ajustan hiperparámetros como mtry, min.bucket, y num.trees.

```{r}
# Predecimos con unos hiperparámetros en la dirección de los óptimos 
model_sexo_impute <- ranger(
  x = data_sexo_undersampl.dt[, ..regressors_sexo], 
  y = data_sexo_undersampl.dt$sexo,
  mtry = 4,
  min.bucket = 10, 
  num.trees = 500,
  importance = 'permutation',
  probability = TRUE, # atención: guardamos la probabilidad para hacer manualmente la predicción
  verbose = TRUE)
```

Se calcula la importancia de cada variable predictora en el modelo.

```{r}
importance <- sort(model_sexo_impute$variable.importance, decreasing = TRUE)
data_sexo_importance.dt <- data.table(
  variable = names(importance),
  importancia = importance)

plot_importancia_var_ranger_sexo <- ggplot(data_sexo_importance.dt, aes(x = reorder(variable, importancia), y = importancia)) +
  geom_col() +
  coord_flip() +
  labs(x = '', y = 'Importancia (permutación)') +
  theme_bw()

ggsave(paste0(output_dir,"/plot_importancia_var_ranger_sexo.jpg"),
			 plot_importancia_var_ranger_sexo, width = 7, height = 7)
```

Se calcula la curva ROC y la matriz de confusión para evaluar el rendimiento del modelo en el conjunto de entrenamiento submuestreado.

```{r}
## AUC, ROC and confusion matrix for undersampled train data ####
prob_sexo_train    <- model_sexo_impute$predictions[, 'HOMBRE']
roc_sexo_train.roc <- roc(data_sexo_undersampl.dt$sexo, prob_sexo_train) # Comparando con pruebas sin submuestreo la AUC no parece cambiar mucho
roc_sexo_train.roc

thrsh <- coords(roc_sexo_train.roc, 'best', best.method="closest.topleft")[["threshold"]] #coordenadas del punto óptimo de la curva ROC

data_sexo_undersampl.dt[
  , sexo := factor(sexo, levels = c('HOMBRE', 'MUJER'))][
  , prob_hombre := prob_sexo_train][
  , sexo_pred := ifelse(prob_hombre >= thrsh, 'HOMBRE', 'MUJER')][
  , sexo_pred := factor(sexo_pred, levels = c('HOMBRE', 'MUJER'))]



```
Matriz de confusión:
```{r}
confMat_sexo_train.lst <- caret::confusionMatrix(as.factor(data_sexo_undersampl.dt$sexo_pred), as.factor(data_sexo_undersampl.dt$sexo))

confMat_sexo_train.lst$byClass
confMat_sexo_train.lst$table
```
Se calcula la curva ROC y la matriz de confusión para evaluar el rendimiento del modelo en todo el conjunto de entrenamiento:

```{r}
## AUC, ROC and confusion matrix for all train data ####
pred_sexo_train <- predict(model_sexo_impute, data = data_sexo.dt)
prob_sexo_train_completo <- pred_sexo_train$predictions[, 'HOMBRE']
roc_sexo_train_completo.roc <- roc(data_sexo.dt$sexo, prob_sexo_train_completo) # Comparando el caso con submuestreo la AUC no parece cambiar mucho
thrsh_completo <- coords(roc_sexo_train_completo.roc, 'best', best.method="closest.topleft")[["threshold"]]
data_sexo.dt[
  , sexo := factor(sexo, levels = c('HOMBRE', 'MUJER'))][
  , prob_hombre := pred_sexo_train$predictions[, 'HOMBRE']][
  , sexo_pred := ifelse(prob_hombre >= thrsh_completo, 'HOMBRE', 'MUJER')][
  , sexo_pred := factor(sexo_pred, levels = c('HOMBRE', 'MUJER'))]
confMat_sexo_completo.lst <- caret::confusionMatrix(as.factor(data_sexo.dt$sexo_pred), as.factor(data_sexo.dt$sexo))
confMat_sexo_completo.lst$byClass
confMat_sexo_completo.lst$table
```

Se imputa el sexo en los datos faltantes:

```{r}
## Impute sex with model (undersampled; no CV) ####
pred_sexo_impute <- predict(model_sexo_impute, data = data_sexo_impute.dt)
prob_sexo_impute <- pred_sexo_impute$predictions[, 'HOMBRE']
data_sexo_impute.dt[
  , prob_hombre := prob_sexo_impute][
  , sexo := ifelse(prob_hombre >= thrsh_completo, 'HOMBRE', 'MUJER')][
  , sexo := factor(sexo, levels = c('HOMBRE', 'MUJER'))]
data_sexo_imputed.dt <- copy(data.dt)[
  , sexo_imp := ifelse(is.na(sexo), TRUE, FALSE)][
  is.na(sexo), sexo := data_sexo_impute.dt$sexo]

saveRDS(data_sexo_imputed.dt, (paste0(output_dir,"/data_sexo_imputed.dt_undersampled.rds")))

```

Visualización de resultados:

```{r}
## Visualise  ####
# Calculamos ratios de hombres y mujeres y visualizamos comparando antes y después 
ratio_sexo_original.dt <- data_sexo_imputed.dt[
  sexo_imp == FALSE, .(ratio_mujeres = sum(sexo == 'MUJER' & sexo_imp == FALSE) / .N, 
                       ratio_hombres = sum(sexo == 'HOMBRE' & sexo_imp == FALSE) / .N), by = c("muni_code_hecho", "yy_hecho", "violencia")]
ratio_missing_original.dt <- data_sexo_imputed.dt[
  , .(ratio_missing = sum(sexo_imp) / .N), by = c("muni_code_hecho", "yy_hecho", "violencia")][
  , dataset := 'original']

ratio_sexo_original.dt <- merge(ratio_sexo_original.dt, ratio_missing_original.dt, by = c("muni_code_hecho", "yy_hecho", "violencia"), all = TRUE)[
  ratio_missing >= 1 & is.na(ratio_mujeres), ratio_mujeres := 0][
  ratio_missing >= 1 & is.na(ratio_hombres), ratio_hombres := 0]

ratio_sexo_imputado.dt <- data_sexo_imputed.dt[
  , .(ratio_mujeres = sum(sexo == 'MUJER') / .N, 
  ratio_hombres = sum(sexo == 'HOMBRE') / .N), by = c("muni_code_hecho", "yy_hecho", "violencia")][
  , ratio_missing := 0][
  , dataset := 'imputado']

ratio_sexo.dt <- rbindlist(list(ratio_sexo_imputado.dt, ratio_sexo_original.dt))

### 1. imputation rates ####
plot_ratio_imp_sexo_under <- ggplot(ratio_sexo.dt, aes(x = dataset, y = ratio_missing, fill = dataset)) +
  geom_boxplot() +
  facet_grid(violencia ~ yy_hecho) +
  labs(x = '', y = 'Tasa de imputación\n') +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

ggsave(paste0(output_dir,"/plot_ratio_imp_sexo_under.jpg"),
			 plot_ratio_imp_sexo_under, width = 15, height = 10)


### 2. sex distributions ####
## No tenemos en cuenta los municipios que se imputan por completo (ratio_missing == 1)
plot_ratio_sexo_under <- ggplot(ratio_sexo.dt[ratio_missing < 1], aes(x = dataset, y = ratio_hombres, fill = dataset)) +
  geom_boxplot() +
  facet_grid(violencia ~ yy_hecho) +
  labs(x = '', y = 'Ratio de hombres\n') +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

ggsave(paste0(output_dir,"/plot_ratio_sexo_under.jpg"),
			 plot_ratio_sexo_under, width = 15, height = 10)

## La imputación no parece perturbar los ratios 
## por año y tipo de violencia, salvo cuando el 
## número de missing es muy alto
```

# Modelo sin submuestreo

Entrenamiento y validación del modelo con K-Fold Cross-Validation sin submuestreo:

```{r}
## Manual (non-repeated) k-fold cross-validation ####

#Construimos los 5 folds
n_rf    <- nrow(data_sexo.dt)
n_folds <- 5
set.seed(543) # For k-fold reproducibility
data_sexo.dt[, fold_idx := sample(1:n_folds, n_rf, replace = TRUE)]

# Train-test para cada fold y cada celda de hiperparametros
roc_sexo_train.lst <- vector(mode = 'list', length = nrow(grid_hyperp.dt))
roc_sexo_test.lst  <- vector(mode = 'list', length = nrow(grid_hyperp.dt))
prob_sexo_test.lst  <- vector(mode = 'list', length = nrow(grid_hyperp.dt))
n_cells <- nrow(grid_hyperp.dt)

for (grid_id in 1:n_cells){
  
  mtry          <- grid_hyperp.dt[grid_id][['mtry']]
  min.node.size <- grid_hyperp.dt[grid_id][['min.node.size']]
  num.trees     <- grid_hyperp.dt[grid_id][['num.trees']]
  
  cat(paste0('mtry= ', mtry, '; min.node.size= ', min.node.size, '; num.trees= ', num.trees, '\n'))
  
  roc_sexo_train.lst[[grid_id]] <- vector('list', n_folds)
  
  for (fold in 1:n_folds){
    
    
    data_train.dt <- data_sexo.dt[fold_idx != fold]
    data_test.dt  <- data_sexo.dt[fold_idx == fold]
    model_sexo <- ranger(
      sexo ~ ., 
      data = data_train.dt,
      splitrule = "gini",
      mtry = mtry,
      min.node.size = min.node.size,
      num.trees = num.trees,
      probability = TRUE)
    pred_sexo_train  <- predict(model_sexo, data = data_train.dt)
    roc_sexo_train.lst[[grid_id]][[fold]] <- roc(data_train.dt$sexo, pred_sexo_train$predictions[, 'HOMBRE'], levels = c('HOMBRE', 'MUJER'))
    
    pred_sexo_test  <- predict(model_sexo, data = data_test.dt)
    roc_sexo_test.lst[[grid_id]][[fold]] <- roc(data_test.dt$sexo, pred_sexo_test$predictions[, 'HOMBRE'], levels = c('HOMBRE', 'MUJER')) 
    prob_sexo_test.lst[[grid_id]][[fold]] <- pred_sexo_test$predictions
    cat(paste0('   fold= ', fold, '; auc_pred= ', auc(roc_sexo_test.lst[[grid_id]][[fold]]), '\n'))
  }    
  names(roc_sexo_train.lst[[grid_id]]) <- paste0('fold= ', 1:n_folds)
  names(roc_sexo_test.lst[[grid_id]])  <- paste0('fold= ', 1:n_folds)

}
names(roc_sexo_train.lst) <- paste0('hyper_cell= ', 1:n_cells)
names(roc_sexo_test.lst) <- paste0('hyper_cell= ', 1:n_cells)

# saveRDS(roc_sexo_train.lst, (paste0(output_dir,"/roc_sexo_train.lst.rds")))
# saveRDS(roc_sexo_test.lst, (paste0(output_dir,"/roc_sexo_test.lst.rds")))

```

Selección de los mejores hiperparámetros:

```{r}
#Calculamos el AUC en cada fold y cada celda
auc_sexo_train.lst <- lapply(roc_sexo_train.lst, function(lst){sapply(lst, function(roc){auc(roc)})})
auc_sexo_train.lst

auc_sexo_test.lst  <- lapply(roc_sexo_test.lst,  function(lst){sapply(lst, function(roc){auc(roc)})})
auc_sexo_test.lst

# Tomamos la media de las AUC en cada celda
auc_sexo_train_main <- sapply(auc_sexo_train.lst, mean)
auc_sexo_train_main

auc_sexo_test_main <- sapply(auc_sexo_test.lst, mean)
auc_sexo_test_main

auc.dt <- data.table(
  hyper_cell = seq_along(auc_sexo_test_main), 
  train = round(auc_sexo_train_main, 3), 
  test  = round(auc_sexo_test_main, 3))
auc.dt <- auc.dt[
  grid_hyperp.dt[, hyper_cell := 1:.N], on = 'hyper_cell']
auc.dt[which.max(auc.dt$test)] # Selecciono el AUC máximo.
# (el modelo optimo parece darse cuando mtry es bajo, min.node-size es bajo y num.trees es alto)
# (el valor de auc no es muy bueno; quiza haya que probar un boosting)
# (el undersampling no parece mejorar el modelo)
# (la cantidad de overfitting no parece reducirse mucho con el undersampling)

```






aqui codigo del prof:

```{r}

# Build model without undersampling and without cross-validation ####
# Variable a imputar: sexo
# Mantenemos las variables etnia, violencia, p_str, edad_categoria como regresores
# convirtiendo sus NA en una nueva categoría * (está hecho más arriba)

# Predecimos con unos hiperparámetros en la dirección de los óptimos encontrados (idealmente deberían estar en los anteriores)
model_sexo_impute <- ranger(
  x = data_sexo.dt[, ..regressors_sexo], 
  y = data_sexo.dt$sexo,
  mtry = 4,
  min.bucket = 10, 
  num.trees = 5000,
  importance = 'permutation',
  probability = TRUE, # atención: guardamos la probabilidad para hacer manualmente la predicción
  verbose = TRUE)

## Variable importance (permutation) ####
importnce <- sort(model_sexo_impute$variable.importance, decreasing = TRUE)
data_sexo_importance.dt <- data.table(
  variable = names(importnce),
  importancia = importnce)
ggplot(data_sexo_importance.dt, aes(x = reorder(variable, importancia), y = importancia)) +
  geom_col() +
  coord_flip() +
  labs(x = '', y = 'Importancia (permutación)') +
  theme_bw()

## AUC, ROC and confusion matrix for all train data ####
pred_sexo_train <- predict(model_sexo_impute, data = data_sexo.dt)
prob_sexo_train_completo <- pred_sexo_train$predictions[, 'HOMBRE']
roc_sexo_train_completo.roc <- roc(data_sexo.dt$sexo, prob_sexo_train_completo) # Comparando el caso con submuestreo la AUC no parece cambiar mucho
thrsh_completo <- coords(roc_sexo_train_completo.roc, 'best')[["threshold"]]
data_sexo.dt[
  , sexo := factor(sexo, levels = c('HOMBRE', 'MUJER'))][
    , prob_hombre := pred_sexo_train$predictions[, 'HOMBRE']][
      , sexo_pred := ifelse(prob_hombre >= thrsh_completo, 'HOMBRE', 'MUJER')][
        , sexo_pred := factor(sexo_pred, levels = c('HOMBRE', 'MUJER'))]
confMat_sexo_completo.lst <- caret::confusionMatrix(as.factor(data_sexo.dt$sexo_pred), as.factor(data_sexo.dt$sexo))
confMat_sexo_completo.lst$byClass

## Impute sex with model (no undersampling; no CV) ####
pred_sexo_impute <- predict(model_sexo_impute, data = data_sexo_impute.dt)
prob_sexo_impute <- pred_sexo_impute$predictions[, 'HOMBRE']
data_sexo_impute.dt[
  , prob_hombre := prob_sexo_impute][
    , sexo := ifelse(prob_hombre >= thrsh_completo, 'HOMBRE', 'MUJER')][
      , sexo := factor(sexo, levels = c('HOMBRE', 'MUJER'))]
data_sexo_imputed.dt <- copy(data.dt)[
  , sexo_imp := ifelse(is.na(sexo), TRUE, FALSE)][
    is.na(sexo), sexo := data_sexo_impute.dt$sexo]

#saveRDS(data_sexo_imputed.dt, file.path(path_data, 'data_sexo_imputed.dt.rds'))


## Visualise ####
# Calculamos ratios de hombres y mujeres y visualizamos comparando antes y después de comparar
ratio_sexo_original.dt <- data_sexo_imputed_nosub.dt[
  sexo_imp == FALSE, .(ratio_mujeres = sum(sexo == 'MUJER' & sexo_imp == FALSE) / .N, 
                       ratio_hombres = sum(sexo == 'HOMBRE' & sexo_imp == FALSE) / .N), by = c("muni_code_hecho", "yy_hecho", "violencia")]
ratio_missing_original.dt <- data_sexo_imputed_nosub.dt[
  , .(ratio_missing = sum(sexo_imp) / .N), by = c("muni_code_hecho", "yy_hecho", "violencia")][
    , dataset := 'original']

ratio_sexo_original.dt <- merge(ratio_sexo_original.dt, ratio_missing_original.dt, by = c("muni_code_hecho", "yy_hecho", "violencia"), all = TRUE)[
  ratio_missing >= 1 & is.na(ratio_mujeres), ratio_mujeres := 0][
    ratio_missing >= 1 & is.na(ratio_hombres), ratio_hombres := 0]

ratio_sexo_imputado.dt <- data_sexo_imputed_nosub.dt[
  , .(ratio_mujeres = sum(sexo == 'MUJER') / .N, 
      ratio_hombres = sum(sexo == 'HOMBRE') / .N), by = c("muni_code_hecho", "yy_hecho", "violencia")][
        , ratio_missing := 0][
          , dataset := 'imputado']

ratio_sexo.dt <- rbindlist(list(ratio_sexo_imputado.dt, ratio_sexo_original.dt))

### 1. imputation rates ####
ggplot(ratio_sexo.dt, aes(x = dataset, y = ratio_missing, fill = dataset)) +
  geom_boxplot() +
  facet_grid(violencia ~ yy_hecho) +
  labs(x = '', y = 'Tasa de imputación\n') +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))


### 2. sex distributions ####
ggplot(ratio_sexo.dt[ratio_missing < 1], aes(x = dataset, y = ratio_hombres, fill = dataset)) +
  geom_boxplot() +
  facet_grid(violencia ~ yy_hecho) +
  labs(x = '', y = 'Ratio de hombres\n') +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

## La imputación no parece perturbar los ratios con estos niveles de desagregación, salvo cuando el número de missing es muy alto

# :===============================: ####
# AUC, ROC y matriz de confusión para el conjunto de entrenamiento completo sin submuestreo ####
model_sexo_impute_nosub <- ranger(
  x = data_sexo.dt[, ..regressors], 
  y = data_sexo.dt$sexo,
  mtry = 4,
  min.bucket = 10, 
  num.trees = 5000,
  importance = 'permutation',
  probability = TRUE, # atención: guardamos la probabilidad para hacer manualmente la predicción
  verbose = TRUE)
prob_sexo_train_nosub    <- model_sexo_impute_nosub$predictions[, 'HOMBRE']
roc_sexo_train_nosub.roc <- roc(data_sexo.dt$sexo, prob_sexo_train_nosub) # Comparando con pruebas sin submuestreo la AUC no parece cambiar mucho
thrsh_nosub <- coords(roc_sexo_train_nosub.roc, 'best')[["threshold"]]
data_sexo_nosub.dt <- copy(data_sexo.dt)[
  , sexo := factor(sexo, levels = c('HOMBRE', 'MUJER'))][
    , prob_hombre := prob_sexo_train_nosub][
      , sexo_pred := ifelse(prob_hombre >= thrsh_nosub, 'HOMBRE', 'MUJER')][
        , sexo_pred := factor(sexo_pred, levels = c('HOMBRE', 'MUJER'))]
confMat_sexo_train_nosub.lst <- caret::confusionMatrix(as.factor(data_sexo_nosub.dt$sexo_pred), as.factor(data_sexo_nosub.dt$sexo))
confMat_sexo_train_nosub.lst$byClass
# Imputamos sexo con la predicción del modelo sin submuestreo
pred_sexo_impute_nosub <- predict(model_sexo_impute_nosub, data = data_sexo_impute.dt)
prob_sexo_impute_nosub <- pred_sexo_impute_nosub$predictions[, 'HOMBRE']
data_sexo_impute.dt[
  , prob_hombre_nosub := prob_sexo_impute_nosub][
    , sexo_nosub := ifelse(prob_hombre_nosub >= thrsh_nosub, 'HOMBRE', 'MUJER')][
      , sexo_nosub := factor(sexo_nosub, levels = c('HOMBRE', 'MUJER'))]
data_sexo_imputed_nosub.dt <- copy(data.dt)[
  , sexo_imp := ifelse(is.na(sexo), TRUE, FALSE)][
    is.na(sexo), sexo := data_sexo_impute.dt$sexo_nosub]

saveRDS(data_sexo_imputed_nosub.dt, file.path(path_data, 'data_sexo_imputed_nosub.dt.rds'))


## Manual (non-repeated) k-fold cross-validation ####
## Grid search for hyperparameters
grid_hyperp.dt <- as.data.table(expand.grid(
  mtry = c(4, length(regressors) - 3),
  min.node.size = c(50, 500),
  num.trees = c(100, 500)))

# Highly unbalanced dataset. We undersample on sexo == 'HOMBRE'
table(data_sexo.dt$sexo)
n_mujeres <- data_sexo.dt[sexo == 'MUJER', .N]
n_hombres <- data_sexo.dt[sexo == 'HOMBRE', .N]
data_sexo_undersampl.dt <- rbindlist(list(
  data_sexo.dt[sexo == 'HOMBRE'][
    sample(c(TRUE, FALSE), n_hombres, prob = c(n_mujeres / n_hombres, 1 - n_mujeres / n_hombres) , replace = TRUE)],
  data_sexo.dt[sexo == 'MUJER']))

#Construimos los 5 folds
n_rf    <- nrow(data_sexo_undersampl.dt)
n_folds <- 5
set.seed(543) # For k-fold reproducibility
data_sexo_undersampl.dt[, fold_idx := sample(1:n_folds, n_rf, replace = TRUE)]

# Train-test para cada fold y cada celda de hiperparámetros
roc_sexo_train.lst <- vector(mode = 'list', length = nrow(grid_hyperp.dt))
roc_sexo_test.lst  <- vector(mode = 'list', length = nrow(grid_hyperp.dt))
prob_sexo_test.lst  <- vector(mode = 'list', length = nrow(grid_hyperp.dt))
n_cells <- nrow(grid_hyperp.dt)
for (grid_id in 1:n_cells){
  
  mtry          <- grid_hyperp.dt[grid_id][['mtry']]
  min.node.size <- grid_hyperp.dt[grid_id][['min.node.size']]
  num.trees     <- grid_hyperp.dt[grid_id][['num.trees']]
  
  cat(paste0('mtry= ', mtry, '; min.node.size= ', min.node.size, '; num.trees= ', num.trees, '\n'))
  
  roc_sexo_train.lst[[grid_id]] <- vector('list', n_folds)
  
  for (fold in 1:n_folds){
    
    
    data_train.dt <- data_sexo_undersampl.dt[fold_idx != fold]
    data_test.dt  <- data_sexo_undersampl.dt[fold_idx == fold]
    model_sexo <- ranger(
      sexo ~ ., 
      data = data_train.dt,
      splitrule = "gini",
      mtry = mtry,
      min.node.size = min.node.size,
      num.trees = num.trees,
      probability = TRUE)
    pred_sexo_train  <- predict(model_sexo, data = data_train.dt)
    roc_sexo_train.lst[[grid_id]][[fold]] <- roc(data_train.dt$sexo, pred_sexo_train$predictions[, 'HOMBRE'], levels = c('HOMBRE', 'MUJER'))
    
    pred_sexo_test  <- predict(model_sexo, data = data_test.dt)
    roc_sexo_test.lst[[grid_id]][[fold]] <- roc(data_test.dt$sexo, pred_sexo_test$predictions[, 'HOMBRE'], levels = c('HOMBRE', 'MUJER')) 
    prob_sexo_test.lst[[grid_id]][[fold]] <- pred_sexo_test$predictions
    cat(paste0('   fold= ', fold, '; auc_pred= ', auc(roc_sexo_test.lst[[grid_id]][[fold]]), '\n'))
  }    
  names(roc_sexo_train.lst[[grid_id]]) <- paste0('fold= ', 1:n_folds)
  names(roc_sexo_test.lst[[grid_id]])  <- paste0('fold= ', 1:n_folds)
  
}
names(roc_sexo_train.lst) <- paste0('hyper_cell= ', 1:n_cells)
names(roc_sexo_test.lst) <- paste0('hyper_cell= ', 1:n_cells)

#Calculamos el AUC en cada fold y cada celda
auc_sexo_train.lst <- lapply(roc_sexo_train.lst, function(lst){sapply(lst, function(roc){auc(roc)})})
auc_sexo_test.lst  <- lapply(roc_sexo_test.lst,  function(lst){sapply(lst, function(roc){auc(roc)})})

# Tomamos la media de las AUC en cada celda
auc_sexo_train_main <- sapply(auc_sexo_train.lst, mean)
auc_sexo_test_main <- sapply(auc_sexo_test.lst, mean)
auc.dt <- data.table(
  hyper_cell = seq_along(auc_sexo_test_main), 
  train = round(auc_sexo_train_main, 3), 
  test  = round(auc_sexo_test_main, 3))
auc.dt <- auc.dt[
  grid_hyperp.dt[, hyper_cell := 1:.N], on = 'hyper_cell']
auc.dt[which.max(auc.dt$test)]

# (el modelo óptimo parece darse cuando mtry es bajo, min.node.size es bajo y num.trees es alto)
# (el valor de auc no es muy bueno; quizá haya que probar un boosting)
# (el undersampling no parece mejorar el modelo)
# (la cantidad de overfitting no parece reducirse mucho con el undersampling)

```



###########################################################################################################################

```{r}
table(violencias_unidas_aux$sexo, violencias_unidas_aux$etnia, useNA = "always")
# Observese que existen muchos registros con NA tanto en sexo como en etnia. 
# Esto aconseja quitar las variables a imputar del conjunto para construir los modelos
# El problema es que los conjuntos de train y test recojan todos los valores posibles de todas las variables que
# entran en el conjunto a imputar

## Preparar el data set para la imputación. Se definen una lista de variables predictoras.
regressors <- c("dept_code_hecho", "muni_code_hecho", "areaoficialkm2_mpio", "discapital_mpio", "frontera_mpio", "macroregion",
                "yy_hecho",
                "violencia",
                "pobl_rur_mpio", "pobl_urb_mpio", "pobl_tot_mpio", "indrural_mpio",  "predo_rural_mpio",
                "y_transf_depto", "g_func_general_depto",  
                "H_coca_depto",
                "asistesc_depto", "per_alfa_depto", "alumn_total_depto", 
                "nac_hombres_depto", "nac_mujeres_depto","tot_nacimientos_depto", "tot_defunciones_depto")

#Datos completos:
data_sexo.dt <- violencias_unidas_aux[   # datos para contruir el modelo. Los NAs de las variables a imputar las asignamos a una nueva categoria.  Registros donde sexo no es NA y se preparan las variables con valores faltantes asignándoles una nueva categoría ('*').
  !is.na(sexo)][
  , sexo := factor(sexo)][  
  is.na(etnia), etnia := '*'][
  is.na(edad_categoria), edad_categoria := '*'][
  is.na(edad_jep), edad_jep := '*'][
  is.na(p_str), p_str := '*'][  
  , c('sexo', regressors), with = FALSE]

 #Datos a imputar:
data_sexo_impute.dt <- violencias_unidas_aux[   # contiene los registros donde sexo es NA y necesita ser imputado.
  is.na(sexo)][ # Unidades a imputar 
  , c('sexo', regressors), with = FALSE] 

```

Configuración de Validación Cruzada y Búsqueda de Hiperparámetros:

```{r}
## Se define una cuadrícula de hiperparámetros para el modelo Random Forest.
grid_hyperp.dt <- as.data.table(expand.grid(
  mtry = c(4, length(regressors) - 3),
  min.node.size = c(50, 500),
  num.trees = c(100, 500)))

# Highly unbalanced dataset. We undersample on sexo == 'HOMBRE'
table(data_sexo.dt$sexo)
n_mujeres <- data_sexo.dt[sexo == 'MUJER', .N]
n_hombres <- data_sexo.dt[sexo == 'HOMBRE', .N]

# Se realiza un submuestreo para balancear el dataset en términos de sexo, ya que el dataset original está desbalanceado (más hombres que mujeres).
data_sexo_undersampl.dt <- rbindlist(list(
  data_sexo.dt[sexo == 'HOMBRE'][
               sample(c(TRUE, FALSE), n_hombres,
               			 prob = c(n_mujeres / n_hombres, 1 - n_mujeres / n_hombres),
               			 replace = TRUE)],
  data_sexo.dt[sexo == 'MUJER']))
```

Entrenamiento y validación del modelo con K-Fold Cross-Validation:

```{r}
#Construimos los 5 folds
n_rf    <- nrow(data_sexo_undersampl.dt)
n_folds <- 5
set.seed(543) # For k-fold reproducibility
data_sexo_undersampl.dt[, fold_idx := sample(1:n_folds, n_rf, replace = TRUE)]

# Train-test para cada fold y cada celda de hiperparametros
roc_sexo_train.lst <- vector(mode = 'list', length = nrow(grid_hyperp.dt))
roc_sexo_test.lst  <- vector(mode = 'list', length = nrow(grid_hyperp.dt))
prob_sexo_test.lst  <- vector(mode = 'list', length = nrow(grid_hyperp.dt))
n_cells <- nrow(grid_hyperp.dt)

for (grid_id in 1:n_cells){
  
  mtry          <- grid_hyperp.dt[grid_id][['mtry']]
  min.node.size <- grid_hyperp.dt[grid_id][['min.node.size']]
  num.trees     <- grid_hyperp.dt[grid_id][['num.trees']]
  
  cat(paste0('mtry= ', mtry, '; min.node.size= ', min.node.size, '; num.trees= ', num.trees, '\n'))
  
  roc_sexo_train.lst[[grid_id]] <- vector('list', n_folds)
  
  for (fold in 1:n_folds){
    
    
    data_train.dt <- data_sexo_undersampl.dt[fold_idx != fold]
    data_test.dt  <- data_sexo_undersampl.dt[fold_idx == fold]
    model_sexo <- ranger(
      sexo ~ ., 
      data = data_train.dt,
      splitrule = "gini",
      mtry = mtry,
      min.node.size = min.node.size,
      num.trees = num.trees,
      probability = TRUE)
    pred_sexo_train  <- predict(model_sexo, data = data_train.dt)
    roc_sexo_train.lst[[grid_id]][[fold]] <- roc(data_train.dt$sexo, pred_sexo_train$predictions[, 'HOMBRE'], levels = c('HOMBRE', 'MUJER'))
    
    pred_sexo_test  <- predict(model_sexo, data = data_test.dt)
    roc_sexo_test.lst[[grid_id]][[fold]] <- roc(data_test.dt$sexo, pred_sexo_test$predictions[, 'HOMBRE'], levels = c('HOMBRE', 'MUJER')) 
    prob_sexo_test.lst[[grid_id]][[fold]] <- pred_sexo_test$predictions
    cat(paste0('   fold= ', fold, '; auc_pred= ', auc(roc_sexo_test.lst[[grid_id]][[fold]]), '\n'))
  }    
  names(roc_sexo_train.lst[[grid_id]]) <- paste0('fold= ', 1:n_folds)
  names(roc_sexo_test.lst[[grid_id]])  <- paste0('fold= ', 1:n_folds)

}
names(roc_sexo_train.lst) <- paste0('hyper_cell= ', 1:n_cells)
names(roc_sexo_test.lst) <- paste0('hyper_cell= ', 1:n_cells)

# saveRDS(roc_sexo_train.lst, (paste0(output_dir,"/roc_sexo_train.lst.rds")))
# saveRDS(roc_sexo_test.lst, (paste0(output_dir,"/roc_sexo_test.lst.rds")))

```

Selección de los mejores hiperparámetros:

```{r}
#Calculamos el AUC en cada fold y cada celda
auc_sexo_train.lst <- lapply(roc_sexo_train.lst, function(lst){sapply(lst, function(roc){auc(roc)})})
auc_sexo_train.lst

auc_sexo_test.lst  <- lapply(roc_sexo_test.lst,  function(lst){sapply(lst, function(roc){auc(roc)})})
auc_sexo_test.lst

# Tomamos la media de las AUC en cada celda
auc_sexo_train_main <- sapply(auc_sexo_train.lst, mean)
auc_sexo_train_main

auc_sexo_test_main <- sapply(auc_sexo_test.lst, mean)
auc_sexo_test_main

auc.dt <- data.table(
  hyper_cell = seq_along(auc_sexo_test_main), 
  train = round(auc_sexo_train_main, 3), 
  test  = round(auc_sexo_test_main, 3))
auc.dt <- auc.dt[
  grid_hyperp.dt[, hyper_cell := 1:.N], on = 'hyper_cell']
auc.dt[which.max(auc.dt$test)]
# (el modelo optimo parece darse cuando mtry es bajo, min.node-size es bajo y num.trees es alto)
# (el valor de auc no es muy bueno; quiza haya que probar un boosting)
# (el undersampling no parece mejorar el modelo)
# (la cantidad de overfitting no parece reducirse mucho con el undersampling)

```

Entrenamiento del modelo final e imputación de valores faltantes:

```{r}

# Predecimos con unos hiperparametros en la direccion de los optimos encontrados (idealmente deberian estar en los anteriores)
model_sexo_impute <- ranger(
  sexo ~ ., 
  data = data_sexo.dt,
  mtry = 4,
  min.node.size = 15,
  min.bucket = 10, 
  num.trees = 1000,
  verbose = TRUE)

# Imputamos sexo con la prediccion del modelo
pred_sexo_impute    <- predict(model_sexo_impute, data = data_sexo_impute.dt)
data_sexo_imputed.dt <- copy(violencias_unidas_aux)[
  , sexo_imp := ifelse(is.na(sexo), TRUE, FALSE)][
  is.na(sexo), sexo := pred_sexo_impute$predictions]
  
saveRDS(data_sexo_imputed.dt, (paste0(output_dir,"/data_sexo_imputed.dt.rds")))

```

Evaluación de la imputación: 

```{r}
# Calculamos ratios de hombres y mujeres y visualizamos comparando antes y despues de comparar
ratio_sexo_total.dt <- data_sexo_imputed.dt[
  , .(ratio_mujeres = sum(sexo == 'MUJER') / .N, ratio_hombres = sum(sexo == 'HOMBRE') / .N), by = c("muni_code_hecho", "yy_hecho", "violencia")][
  , dataset := 'imputado']
ratio_sexo_noNA.dt <- data_sexo_imputed.dt[
  sexo_imp == FALSE, .(ratio_mujeres = sum(sexo == 'MUJER') / .N, ratio_hombres = sum(sexo == 'HOMBRE') / .N), by = c("muni_code_hecho", "yy_hecho", "violencia")][
  , dataset := 'original']
ratio_sexo.dt <- rbindlist(list(ratio_sexo_total.dt, ratio_sexo_noNA.dt))

plt_sexo_ml <- ggplot(ratio_sexo.dt, aes(x = dataset, y = ratio_hombres, fill = dataset)) +
  geom_boxplot() +
  facet_grid(violencia ~ yy_hecho) +
  labs(x = '', y = 'Ratio de hombres\n') +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
## La imputacion no parece perturbar los ratios con estos niveles de desagregacion, salvo algun anho con algun tipo de violencia


ggsave(paste0(output_dir,"/imputacion_ml_sexo.jpg"),
			 plt_sexo_ml, width = 15, height = 10)

```


Agrupamos los resultados para la comparación con los demás métodos: 

```{r}
imputacion_ml_sexo <- data_sexo_imputed.dt %>%
	filter(yy_hecho >= 1996) %>%
	group_by(sexo, yy_hecho, violencia) %>%
  summarise(imp_ml = n()) %>%
  arrange(yy_hecho)

saveRDS(imputacion_ml_sexo, (paste0(output_dir,"/imputacion_ml_sexo.rds")))

```












