---
title: "Contraste de métodos de imputación estadística en la documentación de víctimas del
conflicto armado colombiano"
author: "Valentina Gómez^[[valegome@ucm.es](valegome@ucm.es)]"
date: '`r format(Sys.time(), "%d %B %Y")`'
output: pdf_document
site: "bookdown::bookdown_site"
lang: es-CO
fig_width: 4
fig_height: 2.5
fontsize: 12pt
urlcolor: blue
editor_options: 
  markdown: 
    wrap: sentence
---
# Imputación por Machine Learning - Sexo - Lightgbm

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

require(pacman)
p_load(here, tidyverse, dplyr, data.table, Matrix, vcd, xgboost, caret, ggplot2,
			 pROC, lightgbm)

```

Importación de datos:

```{r}
input_dir <- here::here("06.union/output")
output_dir <- here::here("08.modelos_imputacion/output")

data.dt <- readRDS(paste0(input_dir,"/violencias_unidas_aux.rds")) %>%
	as.data.table()
```

Se establecen los regresores que se utilizaran en el modelo

```{r}
# Prepare data (encodings)####
regressors_sexo <- c(
  "macroregion", "dept_code_hecho", "muni_code_hecho", "areaoficialkm2_mpio", "discapital_mpio", "frontera_mpio",
  "yy_hecho",
  "violencia", 
  "etnia", "p_str", "edad_categoria",
  "pobl_tot_mpio", "indrural_mpio", "predo_rural_mpio",
  "y_transf_depto", "g_func_general_depto",  
  "H_coca_depto",
  "asistesc_depto", "per_alfa_depto", "alumn_total_depto")

data.dt <- data.dt[
  , c('sexo', regressors_sexo), with = FALSE][
  , yy_hecho := as.numeric(yy_hecho)][
  , dept_code_hecho := as.numeric(dept_code_hecho)][
  , muni_code_hecho := as.numeric(muni_code_hecho)][
  is.na(etnia), etnia := '*'][
  is.na(edad_categoria), edad_categoria := '*'][
  is.na(p_str), p_str := '*']

macroregion_levels <- sort(unique(data.dt$macroregion))
macroregion_enc <- seq_along(macroregion_levels) - 1
names(macroregion_enc) <- macroregion_levels

violencia_levels <- sort(unique(data.dt$violencia))
violencia_enc <- seq_along(violencia_levels) - 1
names(violencia_enc) <- violencia_levels

pstr_levels <- sort(unique(data.dt$p_str))
pstr_enc <- seq_along(pstr_levels) - 1
names(pstr_enc) <- pstr_levels

etnia_levels <- sort(unique(data.dt$etnia))
etnia_enc <- seq_along(etnia_levels) - 1
names(etnia_enc) <- etnia_levels

edadCat_levels <- sort(unique(data.dt$edad_categoria))
edadCat_enc <- seq_along(edadCat_levels) - 1
names(edadCat_enc) <- edadCat_levels

edadJep_levels <- sort(unique(data.dt$edad_jep))
edadJep_enc <- seq_along(edadJep_levels) - 1
names(edadJep_enc) <- edadJep_levels

sexo_levels <- sort(unique(data.dt$sexo))
sexo_enc <- seq_along(sexo_levels) - 1
names(sexo_enc) <- sexo_levels

data_enc.dt <- copy(data.dt)[
  , sexo := sexo_enc[sexo]][
  , macroregion := macroregion_enc[macroregion]][
  , violencia := violencia_enc[violencia]][
  , etnia := etnia_enc[etnia]][
  , p_str := pstr_enc[p_str]][
  , edad_categoria := edadCat_enc[edad_categoria]]

```

Se divide el data en casos completos y casos faltantes:

```{r}
data_sexo_enc.dt <- data_enc.dt[          # datos para contruir el modelo, donde sexo no es NA
  !is.na(sexo)]

data_sexo_enc_impute.dt <- data_enc.dt[   # datos a imputar
  is.na(sexo)]

```

Se construye el modelo, pero el conjunto de datos esta desbalanceado (hay más hombres que mujeres) entonces se realiza un submuestreo para balancear la cantidad de observaciones de cada sexo.

```{r}
# Build model with undersampling and without cross-validation ####
# Submuestreamos para tratar la falta de balance en la variable sexo

table(data_sexo_enc.dt$sexo, useNA = 'always')
n_mujeres <- data_sexo_enc.dt[sexo == 1, .N]
n_hombres <- data_sexo_enc.dt[sexo == 0, .N]

set.seed(412)
data_sexo_undersampl.dt <- rbindlist(list(
  data_sexo_enc.dt[sexo == 0][
    sample(c(TRUE, FALSE), n_hombres, prob = c(n_mujeres / n_hombres, 1 - n_mujeres / n_hombres) , replace = TRUE)],
  data_sexo_enc.dt[sexo == 1]))
table(data_sexo_undersampl.dt$sexo, useNA = 'always')

data_sexo_train <- lgb.Dataset(
  Matrix(as.matrix(data_sexo_undersampl.dt[, -1]), sparse = TRUE), 
  label = data_sexo_undersampl.dt$sexo,
  categorical_feature = c(1L, 2L, 3L, 6L, 8L, 9L, 10L, 11L)
)

# categóricas: "macroregion", "dept_code_hecho", 
#              "muni_code_hecho",
#              "frontera_mpio", "violencia", "etnia",
#              "p_str", "edad_categoria"))


lgb_grid <- list(
  objective = "binary",
  metric    = "auc",
  bagging_freq = 5,
  force_row_wise = TRUE
)

hora_inicio <- Sys.time()

model_sexo_impute <- lightgbm(
  data = data_sexo_train, 
  params = lgb_grid, 
  nrounds = 5000L, 
  verbose = 2L
)

hora_fin <- Sys.time()
duracion1 <- hora_fin - hora_inicio
duracion1

    
```
Se calcula AUC, ROC y confusion matrix for undersampled train data:

```{r}
## AUC, ROC and confusion matrix for undersampled train data ####
prob_sexo_train    <- predict(model_sexo_impute, Matrix(as.matrix(data_sexo_undersampl.dt[, -1]), sparse = TRUE))
roc_sexo_train.roc <- roc(data_sexo_undersampl.dt$sexo, prob_sexo_train) # Comparando con pruebas sin submuestreo la AUC no parece cambiar mucho
roc_sexo_train.roc

# Call:
# roc.default(response = data_sexo_undersampl.dt$sexo, predictor = prob_sexo_train)
# 
# Data: prob_sexo_train in 52186 controls (data_sexo_undersampl.dt$sexo 0) < 51875 cases (data_sexo_undersampl.dt$sexo 1).
# Area under the curve: 0.954

thrsh <- coords(roc_sexo_train.roc, 'best', best.method="closest.topleft")[["threshold"]]
data_sexo_undersampl.dt[
  , prob_mujer := prob_sexo_train][
  , sexo_pred := ifelse(prob_mujer >= thrsh, 1, 0)]

table(data_sexo_undersampl.dt$sexo)

#     0     1 
# 52186 51875 

```

Matriz de confusión: 

```{r}
confMat_sexo_train.lst <- caret::confusionMatrix(as.factor(data_sexo_undersampl.dt$sexo_pred), as.factor(data_sexo_undersampl.dt$sexo))
confMat_sexo_train.lst$byClass
confMat_sexo_train.lst$table

# Sensitivity          Specificity       Pos Pred Value       Neg Pred Value            Precision               Recall 
#            0.8850075            0.8700916            0.8726665            0.8826486            0.8726665            0.8850075 
#                   F1           Prevalence       Detection Rate Detection Prevalence    Balanced Accuracy 
#            0.8787936            0.5014943            0.4438262            0.5085863            0.8775495 
#           Reference
# Prediction     0     1
#          0 46185  6739
#          1  6001 45136

```
###


Imputar sexo en los datos faltantes:

```{r}

## Impute sex with model (undersampled; no CV) ####
data_sexo_impute <- Matrix(as.matrix(data_sexo_enc_impute.dt[, -1]), sparse = TRUE)
prob_sexo_impute <- predict(model_sexo_impute, data_sexo_impute)

data_sexo_enc_impute.dt[
  , prob_mujer := prob_sexo_impute][
  , sexo := ifelse(prob_mujer >= thrsh, 1, 0)]

sexo_imp_enc <- data_sexo_enc_impute.dt$sexo
sexo_imputed <- ifelse(sexo_imp_enc == 0, 'HOMBRE', 'MUJER')

data_sexo_imputed.dt <- copy(data.dt)[
  , sexo_imp := ifelse(is.na(sexo), TRUE, FALSE)][
  is.na(sexo), sexo := sexo_imputed]

saveRDS(data_sexo_imputed.dt, (paste0(output_dir,"/data_sexo_imputed.dt_light.rds")))

```

Visualizar resultados:

```{r}
## Visualise  ####
# Calculamos ratios de hombres y mujeres y visualizamos comparando antes y después de comparar
ratio_sexo_original.dt <- data_sexo_imputed.dt[
  sexo_imp == FALSE, .(ratio_mujeres = sum(sexo == 'MUJER' & sexo_imp == FALSE) / .N, 
                       ratio_hombres = sum(sexo == 'HOMBRE' & sexo_imp == FALSE) / .N), by = c("muni_code_hecho", "yy_hecho", "violencia")]
ratio_missing_original.dt <- data_sexo_imputed.dt[
  , .(ratio_missing = sum(sexo_imp) / .N), by = c("muni_code_hecho", "yy_hecho", "violencia")][
  , dataset := 'original']

ratio_sexo_original.dt <- merge(ratio_sexo_original.dt, ratio_missing_original.dt, by = c("muni_code_hecho", "yy_hecho", "violencia"), all = TRUE)[
  ratio_missing >= 1 & is.na(ratio_mujeres), ratio_mujeres := 0][
  ratio_missing >= 1 & is.na(ratio_hombres), ratio_hombres := 0]

ratio_sexo_imputado.dt <- data_sexo_imputed.dt[
  , .(ratio_mujeres = sum(sexo == 'MUJER') / .N, 
  ratio_hombres = sum(sexo == 'HOMBRE') / .N), by = c("muni_code_hecho", "yy_hecho", "violencia")][
  , ratio_missing := 0][
  , dataset := 'imputado']

ratio_sexo.dt <- rbindlist(list(ratio_sexo_imputado.dt, ratio_sexo_original.dt))

### 1. imputation rates ####
plot_ratio_imp_sexo_light <- ggplot(ratio_sexo.dt, aes(x = dataset, y = ratio_missing, fill = dataset)) +
  geom_boxplot() +
  facet_grid(violencia ~ yy_hecho) +
  labs(x = '', y = 'Tasa de imputación\n') +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

ggsave(paste0(output_dir,"/plot_ratio_imp_sexo_light.jpg"),
			 plot_ratio_imp_sexo_light, width = 15, height = 10)


### 2. sex distributions ####
plot_ratio_sexo_light <- ggplot(ratio_sexo.dt[ratio_missing < 1], aes(x = dataset, y = ratio_hombres, fill = dataset)) +
  geom_boxplot() +
  facet_grid(violencia ~ yy_hecho) +
  labs(x = '', y = 'Ratio de hombres\n') +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

ggsave(paste0(output_dir,"/plot_ratio_sexo_light.jpg"),
			 plot_ratio_sexo_light, width = 15, height = 10)

```

Agrupamos los resultados para la comparación con los demás métodos: 

```{r}

colSums(is.na(data_sexo_imputed.dt))
table(data_sexo_imputed.dt$sexo)


imputacion_ml_sexo <- data_sexo_imputed.dt %>%
	filter(yy_hecho >= 1996) %>%
	group_by(sexo, yy_hecho, violencia) %>%
  summarise(imp_ml = n()) %>%
  arrange(yy_hecho)

saveRDS(imputacion_ml_sexo, (paste0(output_dir,"/imputacion_ml_sexo_under_light.rds")))

```




